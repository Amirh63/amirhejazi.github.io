<!DOCTYPE html>
<html lang="en">

<head>
  <title>Projects</title>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="keywords"
    content="Amir Hejazi, amir hejazi, amirhejazi, digital signal processing, DSP, digital communication, SDSU, san diego state university, electrical enginering, dsp, wireless, digital communication, C++, html5,css3,resume,thesis" />
  <meta name="description" content="Creating a website about myself using HTML5 and CSS3." />
  <meta http-equiv="refresh" content="7200" />
  <meta name="author" content="Amir Hejazi" />
  <!-- Assets (HTTPS + proper quoting so they work on secure pages) -->
  <link href="https://fonts.googleapis.com/css?family=Droid+Sans" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="css/style.css" />
  <link rel="icon" type="image/png" href="images/icones/projects_icon.png" />
  <!-- <script type="text/javascript" src="https://codecogs.unisa.ac.za/latexit.js"></script> -->

  <style type="text/css">
    #spn1 {
      display: none;
    }

    #spn2 {
      display: none;
    }

    #spn3 {
      display: none;
    }

    #spn4 {
      display: none;
    }

    #spn5 {
      display: none;
    }

    #spn6 {
      display: none;
    }

    #spn7 {
      display: none;
    }

    #spn8 {
      display: none;
    }

    #spn9 {
      display: none;
    }

    #spn10 {
      display: none;
    }

    #spn11 {
      display: none;
    }

    .tab {
      margin-left: 40px;
    }
  </style>

  <script type="text/javascript">
    function Function1(btn) {
      var x = document.getElementById("spn1");
      var isOpen = x.style.display === "inline";
      x.style.display = isOpen ? "none" : "inline";
      btn.textContent = isOpen ? "More" : "Less";
    }
    function Function2(btn) {
      var x = document.getElementById("spn2");
      var isOpen = x.style.display === "inline";
      x.style.display = isOpen ? "none" : "inline";
      btn.textContent = isOpen ? "More" : "Less";
    }
    function Function3(btn) {
      var x = document.getElementById("spn3");
      var isOpen = x.style.display === "inline";
      x.style.display = isOpen ? "none" : "inline";
      btn.textContent = isOpen ? "More" : "Less";
    }
    function Function4(btn) {
      var x = document.getElementById("spn4");
      var isOpen = x.style.display === "inline";
      x.style.display = isOpen ? "none" : "inline";
      btn.textContent = isOpen ? "More" : "Less";
    }
    function Function5(btn) {
      var x = document.getElementById("spn5");
      var isOpen = x.style.display === "inline";
      x.style.display = isOpen ? "none" : "inline";
      btn.textContent = isOpen ? "More" : "Less";
    }
    function Function6(btn) {
      var x = document.getElementById("spn6");
      var isOpen = x.style.display === "inline";
      x.style.display = isOpen ? "none" : "inline";
      btn.textContent = isOpen ? "More" : "Less";
    }
    function Function7(btn) {
      var x = document.getElementById("spn7");
      var isOpen = x.style.display === "inline";
      x.style.display = isOpen ? "none" : "inline";
      btn.textContent = isOpen ? "More" : "Less";
    }
    function Function8(btn) {
      var x = document.getElementById("spn8");
      var isOpen = x.style.display === "inline";
      x.style.display = isOpen ? "none" : "inline";
      btn.textContent = isOpen ? "More" : "Less";
    }
    function Function9(btn) {
      var x = document.getElementById("spn9");
      var isOpen = x.style.display === "inline";
      x.style.display = isOpen ? "none" : "inline";
      btn.textContent = isOpen ? "More" : "Less";
    }
    function Function10(btn) {
      var x = document.getElementById("spn10");
      var isOpen = x.style.display === "inline";
      x.style.display = isOpen ? "none" : "inline";
      btn.textContent = isOpen ? "More" : "Less";
    }
    function Function11(btn) {
      var x = document.getElementById("spn11");
      var isOpen = x.style.display === "inline";
      x.style.display = isOpen ? "none" : "inline";
      btn.textContent = isOpen ? "More" : "Less";
    }
  </script>
</head>

<body>
  <!-- Header/nav aligned to about.html; CSS styles .topnav -->
  <header class="headtxtalign">
    <nav class="topnav" aria-label="Primary">
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="about.html">About</a></li>
        <li><a href="resume.html">Resume</a></li>
        <li><a href="thesis.html">Thesis</a></li>
        <li><a href="projects.html">Projects</a></li>
        <li><a href="references.html">References</a></li>
        <li><a href="contact.html">Contact</a></li>
      </ul>
    </nav>
  </header>

  <main>
    <section>
      <h5>Design Verification Test Automation:</h5>
      <p>
        Developed and automated test configurations to validate Tibit/Ciena MicroPlug OLT/ONU modules (10G SFP+
        transceivers) across optical, electrical, traffic, and environmental conditions within controlled thermal
        chambers for C-Temp, E-Temp, and I-Temp ranges. Built Python drivers leveraging I2C, UART, and Ethernet
        protocols to interface with measurement instruments, enabling automated testing and reliable data acquisition.
        <span id="spn11">
          Built and maintained end-to-end test stations using optical power meters, optical variable attenuators,
          optical switches, optical wavelength meter, 2x4 PLC optical splitter, an optical add-drop multiplexer,
          Keysight Digital Communication Analyzer, Keysight power supplies, and Teledyne network traffic analyzer to
          measure DUT performance with accuracy and repeatability. Designed and executed verification test-steps in
          Python covering extinction ratio, optical output power, cross-point, jitter, mask margin, receiver
          sensitivity,
          RSSI behavior, power consumption, and traffic performance. Wrote and implemented a Python-based automated
          test using an MVC architecture: the model encapsulated test steps, test harness, state machine, netlist,
          and data processing; the view provided a GUI to display results, temperature corners, and step status; the
          controller handled user inputs, arranged test sequencing, and updated the view. Created post-processing
          pipelines to generate per-module CSV reports; summarized findings for customers and informed data-sheet
          specifications for new MicroPlug designs. Improved measurement consistency, reduced manual rework, and
          increased qualification throughput.
          <br>
        </span>
        <button onclick="Function11(this)">More</button>
      </p>
    </section>

    <section>
      <hr width="88%" size="2px" noshade="noshade">
      <h5> Weather Prediction With Machine Learning:</h5>
      <p>
        For this project, I used a machine-learning algorithm to predict the maximum temperature for the city of Santa
        Rosa, CA. The goal here was to familiarize myself with machine learning algorithms and understand how this can
        be applied to real-world engineering applications. The Gated Recurrent Units (GRU) algorithm was used for this
        project. This is a type of deep neural network algorithm. Neural network algorithms are inspired by the
        structure of the human brain. <span id="spn10">The neural network is a system that takes the training dataset
          and then tries to train itself to understand the patterns in data. Furthermore, the trained neural network is
          used to predict outputs for a new set of similar data. The neural networks are made up of layers of neurons.
          These neurons are the core processing units of the network. The first layer is the input layer which receives
          the input data, the output layer predicts the final output data, in between the input and output layers are
          the hidden layers that perform the computation requirements for the network.
          <br>
          To better understand the GRU algorithm, let's review how the recurrent neural network (RNN) works. First, the
          input information gets transformed into machine-readable vectors. Then the RNN processes the sequence of
          vectors one by one. During this process, it passes the previous hidden state to the next step of the sequence.
          The hidden state acts as the memory of the neural network. It holds information on previous data the network
          has seen before. The GRU is the newer version of recurrent neural networks. It uses the hidden state to
          transfer
          information. It has two gates, a reset gate, and an update gate. The figure below shows the internal
          components of the GRU algorithm.
          <br><br>
          <img src="images/projects/ml/gru.png" alt="GRU RNN" class="set3">
          <br>
          <i><b>Notation:</b></i>
          <br>
          <img src="images/projects/ml/note.png" alt="notation" class="set5">
          <br>
          where,
          <br>
          <!-- For fastest and simplest runtime: MathML (XML-based markup language for encoding math) is directly used in HTML.   -->
          <!-- h_t -->
          <math>
            <msub>
              <mi>h</mi>
              <mi>t</mi>
            </msub>
          </math> is hidden layer vectors,<br>

          <!-- x_t -->
          <math>
            <msub>
              <mi>x</mi>
              <mi>t</mi>
            </msub>
          </math> is the input vector,<br>

          <!-- b_z, b_r, b_h -->
          <math>
            <mrow>
              <msub>
                <mi>b</mi>
                <mi>z</mi>
              </msub>
              <mo>,</mo>
              <msub>
                <mi>b</mi>
                <mi>r</mi>
              </msub>
              <mo>,</mo>
              <msub>
                <mi>b</mi>
                <mi>h</mi>
              </msub>
            </mrow>
          </math>
          are bias vectors for update gate, reset gate and hidden layers, <br>

          <!-- W_z, W_r, W_h -->
          <math>
            <mrow>
              <msub>
                <mi>W</mi>
                <mi>z</mi>
              </msub>
              <mo>,</mo>
              <msub>
                <mi>W</mi>
                <mi>r</mi>
              </msub>
              <mo>,</mo>
              <msub>
                <mi>W</mi>
                <mi>h</mi>
              </msub>
            </mrow>
          </math>
          are the weight matrix for update gate, reset gate and hidden layers, <br>
          <!-- sigma, tanh -->
          <math>
            <mrow>
              <mi>σ</mi>
              <mo>,</mo>
              <mi>tanh</mi>
            </mrow>
          </math> are activation functions.
          <br><br>

          The update gate (
          <math>
            <msub>
              <mi>z</mi>
              <mi>t</mi>
            </msub>
          </math>
          ) deciphers what information to throw away and what new information to add. The reset gate (
          <math>
            <msub>
              <mi>r</mi>
              <mi>t</mi>
            </msub>
          </math>

          ) is used to decide how much past information to forget. Now let’s look at the python code for this project. I
          broke down the code into different segments to better understand the process.
          <br><br>
          <b>Dataset:</b>
          <br>
          I downloaded the temperature dataset for the city of Santa Rosa, CA from the national weather center (NOAA)
          website in a .csv format.
          <br><br>
          <b>Python libraries:</b>
          <br>
          Imported the required python libraries for this project. Furthermore, I used the Tensorflow library to create
          the model for this project.
          <br><br>
          <img src="images/projects/ml/lib.png" alt="library" class="set2">
          <br><br>
          <b>Random seed value:</b>
          <br>
          I set the seed value for the random value generator function to zero to ensure that the results are
          repeatable.
          <br><br>
          <img src="images/projects/ml/seed.png" alt="random seed value" class="set4">
          <br><br>
          <b>Read &amp; filter desired data:</b>
          <br>
          I used the Pandas Dataframe python library to extract the data for the maximum temperature and the date
          columns from the .csv file.
          <br><br>
          <img src="images/projects/ml/file.png" alt="read file from .csv file" class="set3">
          <br><br>
          <b>Handle missing values:</b>
          <br>
          Generally, they are two options to deal with missing values in your dataset:
          <br>
          <i class="tab">1) Replace the missing value with the median value from the dataset.</i>
          <br>
          <i class="tab">2) Drop the row(s) that contain the missing values from the dataset.</i>
          <br>
          I decided to drop the rows with missing values for my dataset since I had a sufficient amount of data.
          <br><br>
          <img src="images/projects/ml/miss_vals.png" alt="read file from .csv file" class="set4">
          <br><br>
          <b>Time-series plot:</b>
          <br>
          To better understand the data, I plotted the time series weather temperature dataset.
          <br><br>
          <img src="images/projects/ml/plot_1.png" alt="time-series plot code" class="set2">
          <br><br>
          <b>Data transformation:</b>
          <br>
          To improve the deep learning neural network model's stability, performance data scaling/normalization is
          highly recommended. I used the MinMaxScaler from the scikit-learn python library to normalize the dataset
          between -1 and 1.
          <br><br>
          <img src="images/projects/ml/norm.png" alt="data transformation" class="set3">
          <br><br>
          <b>Split the dataset into train and test data:</b>
          <br>
          I used 74% of data for train data and the remaining 26% as test data. The goal here was to train the model
          with train data and validate the model’s performance with the test data.
          <br><br>
          <img src="images/projects/ml/train.png" alt="train dataset" class="set3">
          <br><br>
          <b>Create input data for the model:</b>
          <br>
          The GRU model takes 3-dimensional input data. The input data needs to be in the format defined below for the
          model to accept the input data.
          <br><br>

          <math>
            <mrow>
              <mi>input</mi>
              <mo>(</mo>
              <mtext>Sample, Time_Step, Features</mtext>
              <mo>)</mo>
            </mrow>
          </math>

          <br><br>
          The model will use the number of the previous time-step to make a prediction. In this case, time-step/window
          equals 181 days. This means that the model makes predictions based on the last 181-days data. Feature defines
          the number of outputs for the model.
          <br><br>
          <img src="images/projects/ml/input_1.png" alt="input" class="set3">
          <br>
          <img src="images/projects/ml/input_2.png" alt="input" class="set3">
          <br>
          <br>
          The shape of the input dataset for the model is (1438, 181, 1).
          <br><br>
          <b>GRU model:</b>
          <br>
          I used the Tensorflow python library to generate the GRU model. The model consists of one input layer, four
          hidden layers, and two dense layers where the last dense layer is the output layer. The input layer and each
          of the hidden layers have 128 units/neurons. The output layer consists of 1 unit/neuron. The <a
            href="https://medium.datadriveninvestor.com/overview-of-different-optimizers-for-neural-networks-e0ed119440c3"
            target="_blank">Nesterov-accelerated Adaptive Moment Estimation (Nadam)</a> optimizer with a learning rate
          of 0.001318 was utilized to train the model. Furthermore, the loss function for the optimizer is huber_loss.
          To make the model robust against overfitting, the Dropout function is used. The dropout rate for this model is
          about 3.05%. This means the model will drop 3.05% of the units from the network.
          <br><br>
          <img src="images/projects/ml/model.png" alt="GRU model" class="set3">
          <br><br>
          <b>Predict and transform the data:</b>
          <br>
          After the model was trained, I generated the predicted values via the trained model. Then, I transformed the
          data to its original format to evaluate the model’s performance.
          <br><br>
          <img src="images/projects/ml/pred.png" alt="Predict values" class="set6">
          <br><br>
          <b>System performance:</b>
          <br>
          The model’s performance was evaluated based on the following items:
          <br>
          <i class="tab">1) The plot of the training loss and the validation loss.</i>
          <br>
          <i class="tab">2) The root mean square error (RMSE).</i>
          <br>
          <i class="tab">3) The lift chart plot of the predicted data versus the test data.</i>
          <br>
          <i class="tab">4) Finally, compare the predicted data versus the actual data.</i>
          <br><br>
          As it is shown below, the plot of the loss function for the model is converging to zero. This is the measure
          of how well the model's predictions are to the actual values.
          <br><br>
          <img src="images/projects/ml/loss.png" alt="loss function" class="set1">
          <br><br>
          Next, the RMSE value for the model was calculated. RMSE is the standard deviation of the prediction errors
          (residuals). It is a measure of how spread out these residuals are. It is used to define how concentrated the
          data is around the line of best fit. The RMSE value for this model is 5.2758.
          <br><br>
          A lift chart is another tool that is used to depict the accuracy of the model. This is done by sorting the
          predicted and expected values. Then plotted both datasets. The closer the predicted and expected lines are,
          the more accurate your model is as it is shown below.
          <br><br>
          <img src="images/projects/ml/lift.png" alt="lift chart" class="set1">
          <br><br>
          The final plot consisted of comparing the actual data versus the predicted data. As it is shown below, the
          model was able to predict the maximum temperature with good precision.
          <br><br>
          <img src="images/projects/ml/final_plot.png" alt="final plot" class="set1">
          <br><br>
          Please click on the link below to download the source code from GitHub for this project.
          <br>
          <a href="https://github.com/Amirh63/gru_model_weather_prediction" target="_blank">Source Code</a>
          <br>
        </span>
        <button onclick="Function10(this)">More</button>
      </p>
    </section>

    <section>
      <hr width="88%" size="2px" noshade="noshade">
      <h5>Water Impedance Test Stand:</h5>
      <p>
        I was assigned to develop an improved water impedance test stand in order to measure the pressure drop for
        the unit under test. The process consisted of finding the test equipment (such as: flow meter, pressure
        transducer, water pump, etc.) with required specifications. I assembled and tested the hardware as well
        as wrote a program in C# that automated the test station. <span id="spn9">The test stand was optimized in
          the software and the hardware resulting in more accurate and precise measurements. I created a user
          friendly GUI for the test stand so that the technicians and operators could easily utilize the test stand.
          During the creation of the test stand empirical data was collected and analyzed. The data analyses
          consisted of a correlational test (linear regression analysis in Minitab) and repeatability test.
          The results rendered indicated that the new test stand had superior performance in hardware and software
          functionality. The equation below depicts how the pressure drop was calculated:
          <br><br>
          <img src="images/projects/waterimpedanceteststand/pressuredropequation.png" alt="pressure drop equation"
            class="pressuredrop">
          <br>
          <i><b>Pressure Drop Equation</b></i>
          <br><br>
          where, <br>
          <!-- Q -->
          <math>
            <mi>Q</mi>
          </math> is the flow rate <br>

          <!-- D -->
          <math>
            <mi>D</mi>
          </math> is the pipe/tube inner diameter <br>

          <!-- L -->
          <math>
            <mi>L</mi>
          </math> is the pipe/tube length <br>

          <!-- mu -->
          <math>
            <mi>μ</mi>
          </math> is the dynamic viscosity <br>

          <!-- P1 - P2 -->
          <math>
            <mrow>
              <msub>
                <mi>P</mi>
                <mn>1</mn>
              </msub>
              <mo>−</mo>
              <msub>
                <mi>P</mi>
                <mn>2</mn>
              </msub>
            </mrow>
          </math>
          is the pressure drop <br>

          <br>
          Furthermore, the impedance is calculated based on the measured pressure drop and the flow rate as shown below:
          <br><br>
          <!-- Impedance = Pressure Drop / Flow Rate -->
          <math>
            <mrow>
              <mi>Impedance</mi>
              <mo>=</mo>
              <mfrac>
                <mtext>Pressure Drop (PSI)</mtext>
                <mtext>Flow Rate (mL/min)</mtext>
              </mfrac>
            </mrow>
          </math>
          <br>
        </span>
        <button onclick="Function9(this)">More</button>
      </p>
    </section>

    <section>
      <hr width="88%" size="2px" noshade="noshade">
      <h5>Automation Test Development:</h5>
      <p>
        Tasked with developing automation diagnostic tools to test the DELL servers on a system level. The process
        consisted of writing the test in C# by converting some of the frameworks and libraries from Python. By
        developing the automation test in the C# environment, the test structure, re-usability, efficiency, and
        reliability was improved. <span id="spn1"> I maintained, updated/modified, and reviewed the automation test
          scripts written in Python to test the functionalities of the DELL server systems that were in production. The
          automation test was API (Application Programming Interface) driven due to its stability and short release
          cycles and fast feedback loops. Converting the Python code to C# improved the overall test robustness.
          Furthermore, we ran the test scripts on a Cumulus network environment in order to test the UUT (Unit Under
          Test). Since the Cumulus network is based on a .Net framework, writing the automation test in C# improved the
          testing time by a large margin. During this process we used Mercurial as a source control in order to
          maintain, modify and update the scripts.
          <br>
        </span>
        <button onclick="Function1(this)">More</button>
      </p>
    </section>

    <section>
      <hr width="88%" size="2px" noshade="noshade">
      <h5>DSP Based Phase-Locked Loop:</h5>
      <p>
        Phase-locked loop (PLL) is a control system that is designed to align the phase and frequency of the phase
        accumulator with the complex sampled data of the input signal. PLL has many applications within communication
        systems such as: demodulators, signal reconstruction, clock recovery, and frequency synthesizer.<span id="spn2">
          <br><br>
          The building blocks for a PLL consist of:
          <br>
          1. Phase detector <br>
          2. Loop filter <br>
          3. DDS (Direct Digital Synthesis) <br><br>
          The phase detector is used to estimate the error between the input signal and the reference signal. The loop
          filter is responsible for removing the noise and tracking the time-varying input phase. The DDS is designed to
          generate the reference frequency. In a PLL, the DDS is used as a local oscillator. Below is a block diagram of
          the DSP based phase-locked loop.
          <br><br>
          <img src="images/pll/pll.png" alt="PLL block diagram" class="pll">
          <br>
          <i><b>PLL Block Diagram</b></i>
          <br><br>
          The Python program loop steps through the following operations:
          <br>
          1. The phase detector is used to estimate the phase error. <br>
          2. The loop filter is used to remove the errors and track the phase of the input signal. <br>
          3. The DDS is used as a local oscillator to generate the reference signal. <br>
          The closed loop transfer function of the aforementioned model is depicted below:
          <br><br>
          <img src="images/pll/ZTF.png" alt="PLL closed loop TF" class="TF">
          <br><br>
          The parameters for the z-transform model are as follows:
          <br><br>
          <img src="images/pll/param.png" alt="Z TF parameters" class="parameters">
          <br><br>
          where, <br>

          <!-- w_n -->
          <math>
            <msub>
              <mi>w</mi>
              <mi>n</mi>
            </msub>
          </math> is the bandwidth of the loop filter <br>

          <!-- theta_n -->
          <math>
            <msub>
              <mi>θ</mi>
              <mi>n</mi>
            </msub>
          </math> is the digital undamped natural frequency <br>

          <!-- K_p -->
          <math>
            <msub>
              <mi>K</mi>
              <mi>p</mi>
            </msub>
          </math> is the proportional loop filter gain <br>

          <!-- K_i -->
          <math>
            <msub>
              <mi>K</mi>
              <mi>i</mi>
            </msub>
          </math> is the integral loop filter gain <br>

          <!-- zeta and zeta = 0.707 -->
          <math>
            <mi>ζ</mi>
          </math> is the loop filter damping factor
          (typically <math>
            <mrow>
              <mi>ζ</mi>
              <mo>=</mo>
              <mn>0.707</mn>
            </mrow>
          </math>)

          <br><br>
          The first plot shows a comparison of the real and imaginary parts of the input signal versus the output
          signal. In Fig.1, the phase of the output signal is locked to the phase of the input signal after
          approximately 110 to 120 samples. The second plot demonstrates the phase difference between the input and the
          reference signal.
          <br><br>
          <img src="images/pll/outputvsinput.png" alt="input vs output signal" class="inputoutputsig">
          <br>
          <i><b>Figure 1</b></i>
          <br><br>
          <img src="images/pll/phasediff.png" alt="phase error" class="phase">
          <br>
          <i><b>Figure 2</b></i>
          <br><br>
          <a href="/programs/python/pll.py">Click here to download the source code in Python</a>
          <br>
        </span>
        <button onclick="Function2(this)">More</button>
      </p>
    </section>

    <section>
      <hr width="88%" size="2px" noshade="noshade">
      <h5>Low Frequency Oscillation (LFO) Signals:</h5>
      <p>
        Tasked to find the root-cause of LFO signals which distorted the spectral purity of the desired signal. LFOs are
        generally undesired parasitic signals in electronic devices. It was determined that the LFOs were generated
        because of a mismatch of the system on the frequency multiplier board. The impedance mismatch was between the
        output<span id="spn3"> of the limiting amplifier (with 50 ohm output impedance) and the input of the Balun (with
          25 ohm input impedance). Accordingly, the impedance mismatch caused some of the incident power to be reflected
          back and created instability of the limiting amplifier. As a result, the LFOs were generated at approximately
          2 to 5 KHz offset from the carrier. One option was to replace the Balun completely. Due to complexity of the
          aforementioned solution, an alternative route was explored. A PI-Pad was designed in Advanced Design Systems
          with a 0402 dimension size resistors and was placed between the output of the limiting amplifier and the input
          of the Balun. By terminating the active component with resistive loads resulted in reducing the effect of
          parasitic oscillation on the desire signal and in some frequency bands the LFOs were completely removed.
          <br><br>
          <img src="images/projects/mismatch.png" alt="impedance mismatch" class="pressuredrop">
          <br>
        </span>
        <button onclick="Function3(this)">More</button>
      </p>
    </section>

    <section>
      <hr width="88%" size="2px" noshade="noshade">
      <h5> Spectral Station: </h5>
      <p>
        Maintained and supported the spectral station. The station tested the Agile Signal Generator (UXG) instruments
        for Harmonics, Subharmonics, and Spurious signals with a spectral analyzer. The algorithm for the test was
        written in C#. The test incorporated Standard Commands for Programmable Instruments (SCPI) in order to
        communicate<span id="spn4"> with the instrument. A data-pack was utilized to define the frequency resolutions
          for the testing process.
          <br><br>
          <i>General Information:</i>
          <br>
          The spectral purity of a Continuous Waveform (CW) source is largely affected by non-ideal components of the
          system. The effect of the non-ideal components on the actual signal results in degradation of the power
          quality of the signal. Below is a list of different types of spurious signals:
          <br>
          1. Harmonic Signals
          <br>
          2. Subharmonic Signals
          <br>
          3. Spurious Signals
          <br><br>
          <i>Harmonic and Subharmonic Distortions:</i>
          <br>
          Harmonics are undesired signals at integer multiples (sub-multiples) of the carrier frequency. The distorted
          signal is created by the nonlinearity characteristic of the microwave components in the RF chain (such as
          mixers, local oscillators, amplifiers, etc.).
          <br><br>
          <i>The difference between harmonic/subharmonic versus spurious signals:</i>
          <br>
          1. Harmonics (or subharmonics) signals are integer multiples (or submultiples) of the input frequency.
          <br>
          2. Spurious signals are presented at non-integer multiples of the input frequency.
          <br>
        </span>
        <button onclick="Function4(this)">More</button>
      </p>
    </section>

    <section>
      <hr width="88%" size="2px" noshade="noshade">
      <h5> Pulse Station: </h5>
      <p>
        Maintained and supported the pulse station. The station tested the UXG instruments for “Pulse Amplitude
        Accuracy/ Pulse power”, “Pulse Width”, “Pulse Delay”, “Overshoot”, “Compression”, and “Video Feedthrough” via a
        Digital Sampling Oscilloscope (DSO). The algorithm for the test was written in Rocky Mountain Basic (RMB). <span
          id="spn5">Furthermore, General Purpose Interface Bus (GPIB) controllers were used for data communication and
          SCPI commands were used to set the instrument states.
          <br><br>
          <i>General Information:</i>
          <br>
          In general Pulsed-RF tests are executed with either a spectrum analyzer or Oscilloscope. For this test a
          Digital Sampling Oscilloscope (DSO) was used to accurately characterize the performance of the pulse
          waveforms. The characteristics of a pulsed signal are used to define the performance and capability of the
          instrument. Some of the terminology for the pulse measurement is defined as follows:
          <br>
          1. Rise time is defined as the 10% to 90% mark on the rising edge of the pulse signal.
          <br>
          2. Fall time is defined as the 10% to 90% mark on the falling edge of the pulse signal.
          <br>
          3. Pulse width is defined as the 50% mark on the rising edge to the 50% mark on the falling edge of the pulse
          signal
          <br>
          4. Pulse Period is defined as the time interval between the rising edges of the two consecutive pulse signals.
          <br>
          5. Overshoot is defined as the maximum voltage level of the pulse top amplitude.
          <br>
          6. Pulse delay is defined as the time interval between the 50% mark on the rising edge of the trigger output
          and the 50% mark on the rising edge of the pulse signal.
          <br>
          7. Video feedthrough is a specification term which is used to define the pulse performance for microwave
          synthesizers. Video feedthrough is defined as the amount of drive signal from the modulator leaks into the RF
          output. Basically, the spurious signals appeared at the RF ports of the switch when the port is switched
          without an RF signal present. Generally the frequency content of video feedthrough signal is concentrated
          below 250 MHz. The pulse test consisted of a lowpass filter (with passband of 250MHz) that extracted the video
          feedthrough signal from the RF signal.
          <br><br>
          <img src="images/projects/pulse.png" alt="Pulse waveform" class="pulse-small">
          <br>
          <i><b>Pulse Waveform</b></i>
          <br>
        </span>
        <button onclick="Function5(this)">More</button>
      </p>
    </section>

    <section>
      <hr width="88%" size="2px" noshade="noshade">
      <h5> Data Analysis: </h5>
      <p class="text">
        Setting the Test Line Limits (TLL) for production instruments consisted of: characterizing the product
        performance, deciphering the performance drifts either due to aging of the RF components or the effect of
        temperature variation of the environment on the instrument, and determining the uncertainty of the measurement
        (AKA, measurement uncertainty).<span id="spn6"> A Gaussian distribution was utilized to accurately characterize
          the measured sample data. This process involved collecting and analyzing the sample data by using descriptive
          statistics such as the mean (to define the center of the distribution) and the standard deviation (to
          determine the degree of deviation from the mean), etc. Moreover, a histogram and normal plots were used to
          delineate the outliers in the data set as well as define the upper and lower limits of the normal distribution
          (data that was 2.5 standard deviations from the mean was not included). Other terms that were used for this
          process are explained below:
          <br>
          1. The <i>confidence level C</i> is the probability that our TLL setting process will produce a passing rate
          (that is at least our desired passing rate). The more samples you have in your data set, the higher your
          confidence level is going to be.
          <br>
          2. The <i>proportion P</i> is our best estimate of the minimum future turn-on rate (passing rate). It is the
          proportion of devices that pass the production test at initial turn-on.
          <br>
          3. The <i>test line limit (TLL)</i> is the pass/fail threshold of the production test.
          <br>
          4. <i>Repeatability and Reproducibility</i> are the two components of precision in a measurement system.
          <br>
          5. <i>Repeatability</i> is the ability of an operator to consistently repeat the same measurement of the same
          part, using the same gage, under the same conditions.
          <br>
          6. <i>Reproducibility</i> is the ability of a gage, used by multiple operators, to consistently reproduce the
          same measurement of the same part, under the same conditions.
          <br><br>
          <img src="images/projects/normaldist/normal_dist.png" alt="normal distribution" class="normaldist">
          <br>
          <i><b>Normal Distribution</b></i>
          <br>
        </span>
        <button onclick="Function6(this)">More</button>
      </p>
    </section>

    <section>
      <hr width="88%" size="2px" noshade="noshade">
      <h5>Pool Playing Robot:</h5>
      <p>
        Designed a pool-playing robot that would detect red or blue balls with the use of programmable camera and then
        shoot the ball into a particular pocket based on information from the sensors. The parts for the robot consist
        of a ball-shooting solenoid, a ball-capturing clamp, ultrasonic sensors, and a color detetion camera system.
        <span id="spn7">The project was ranked first amongst all the other competitors. Some of the videos of the
          constructed robot are listed below:
          <br><br>
          <iframe class="center" src="https://www.youtube.com/embed/4Exbsvoi1GY" frameborder="0"
            allowfullscreen></iframe>
          <iframe class="center" src="https://www.youtube.com/embed/GllQxw8T8oQ" frameborder="0"
            allowfullscreen></iframe>
          <iframe class="center" src="https://www.youtube.com/embed/BGulR3Zlg6w" frameborder="0"
            allowfullscreen></iframe>
        </span>
        <button onclick="Function7(this)">More</button>
      </p>
    </section>

    <section>
      <hr width="88%" size="2px" noshade="noshade">
      <h5> C++ Course Work: </h5>
      <p>
        I have begun to expand my knowledge in the area of programming by taking a C++ course. Some of the programs I
        wrote for the class are listed below: <span id="spn8">
          <br>
          1. Created a calculator using a "switch statement".<br>
          <a href="programs/cpp/calculator.cpp">Source Code</a><br>
          2. Created a rocket shape based on the user input of three values height, width, and stages using the concept
          of "functional decomposition". <br>
          <a href="programs/cpp/rocketProgram.cpp">Source Code</a><br>
          3. Designed and implemented a C++ structure data type for monthly budget expenditures. The program has two
          monthly budget structure variables. One structure variable will hold budget figures and the second structure
          variable will prompt the user to enter the actual expenditures for the past month. the structure variables are
          passed to the functions as parameters to compare expenses and display budgets.
          <br>
          <a href="programs/cpp/monthlyBudget.cpp">Source Code</a><br>
          4. Designed and implemented a fraction class data type. The program consisted of three parts: the class
          specification file (where the data and fucntion declaration occured), the class implementation file (where I
          declared the function definitions), and the client file. The program adds or subtracts fractions.
          <br>
          <a href="programs/cpp/fraction.cpp">Source Code</a><br>
          5. Created a game of life computer simulation program utilizing a two-dimensional array operation. The
          simulation process consist of the life and death events of a population of organisms. This program will
          determine the life, death, and survival of bacteria from one generation to the next, assuming the starting
          grid of bacteria is generation zero.
          <br>
          <a href="programs/cpp/gameoflife.zip">Source Code</a><br>
        </span>
        <button onclick="Function8(this)">More</button>
      </p>
    </section>
  </main>

  <footer id="bottomMenuInfo" role="navigation" aria-label="Footer">
    <div class="bottom-inner">
      <a href="index.html">Home</a>
      <a href="about.html">About</a>
      <a href="resume.html">Resume</a>
      <a href="thesis.html">Thesis</a>
      <a href="projects.html">Projects</a>
      <a href="references.html">References</a>
      <a href="contact.html">Contact</a>
    </div>
  </footer>
</body>

</html>
